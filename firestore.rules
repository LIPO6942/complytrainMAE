/**
 * Core Philosophy: This ruleset implements a Role-Based Access Control (RBAC) model
 * with two primary roles: 'admin' and 'user'. Admins have broad read access for
 * oversight, while regular users are strictly confined to their own data,
 * ensuring strong privacy and data ownership.
 *
 * Data Structure: User-specific data is stored under `/users/{userId}`. Global
 * data, such as departments and courses, is located in top-level collections.
 * Administrator status is efficiently managed by a `role` field within each
 * user's document.
 *
 * Key Security Decisions:
 * - Admin access is granted by reading the `role` field from the user's own
 *   document. This is a common pattern for RBAC.
 * - Users can only read and modify their own `/users/{userId}` document. Listing
 *   other users is forbidden to protect Personally Identifiable Information (PII).
 * - Global data collections like `/departments` and `/courses` are read-only for
 *   all signed-in users. Writes are restricted to admins, indicating that this
 *   data should be managed by a trusted role.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ----------------------------------------------------------------------
    // Helper Functions
    // ----------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the given userId.
     * This is the foundation for the ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    /**
     * Checks if the user is a designated administrator by checking the 'role'
     * field in their own user document.
     */
    function isAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'admin';
    }

    /**
     * Combines an ownership check with an existence check.
     * CRITICAL: Ensures that update/delete operations target existing documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the user creating their own document also sets the
     * internal 'id' field to their own UID, ensuring relational integrity.
     */
    function isCreatingOwnUserDoc(userId) {
      return isOwner(userId) && request.resource.data.id == userId;
    }

    /**
     * On update, ensures the internal 'id' field is immutable. This prevents
     * re-assigning ownership of the document.
     */
    function userDocumentIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    // ----------------------------------------------------------------------
    // Collection Rules
    // ----------------------------------------------------------------------

    /**
     * @description Users can create, read, and update their own profile. Admins can read any profile for oversight and manage roles.
     * @path        /users/{userId}
     * @allow       (create) A new user 'user123' creates their own doc at /users/user123.
     * @allow       (get) An admin user gets the doc at /users/user456.
     * @allow       (list) Admins can list all users.
     * @allow       (update) An admin can update any user's role.
     * @deny        (get) A user 'user123' is denied from reading /users/user456.
     * @principle   Restricts access to a user's own data tree and provides read-only admin oversight.
     */
    match /users/{userId} {
      allow get: if isOwner(userId) || isAdmin();
      allow list: if isAdmin();
      allow create: if isCreatingOwnUserDoc(userId);
      allow update: if (isExistingOwner(userId) && userDocumentIsImmutable()) || isAdmin();
      allow delete: if false;
    }

    /**
     * @description Allows any signed-in user to read department information. Writes are disabled from the client.
     * @path        /departments/{departmentId}
     * @allow       (get) Any signed-in user gets a department document.
     * @deny        (create) Any user is denied from creating a new department.
     * @principle   Treats this collection as read-only data for clients. Writes must be managed by a trusted backend.
     */
    match /departments/{departmentId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Stores all available compliance courses. Readable by all signed-in users, but only writable by admins.
     * @path        /courses/{courseId}
     * @allow       (list, get) Any signed-in user can view the list of available courses.
     * @allow       (create, update, delete) Only admins can add, modify, or remove courses.
     * @principle   Enforces a clear separation of content consumption (all users) and content management (admins).
     */
    match /courses/{courseId} {
      allow read: if isSignedIn();
      allow write: if isAdmin();

      /**
       * @description Stores quiz data for a specific course. Readable by all signed-in users, but only writable by admins.
       * @path        /courses/{courseId}/quizzes/{quizId}
       * @allow       (list, get) Any signed-in user can view the quiz for a course.
       * @allow       (create, update, delete) Only admins can manage quizzes.
       * @principle   Nested data inherits the parent's read/write restrictions but can be further restricted.
       */
      match /quizzes/{quizId} {
        allow read: if isSignedIn();
        allow write: if isAdmin();
      }
    }

    /**
     * @description Stores user invitations. Only admins can create/read them.
     * @path /invitations/{invitationId}
     * @allow (read, create): if isAdmin();
     * @allow (update, delete): if false;
     * @principle Only admins can invite new users.
     */
    match /invitations/{invitationId} {
        allow read, create: if isAdmin();
        allow write: if false;
    }
  }
}
